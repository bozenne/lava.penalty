% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Penalty_estimate.R
\name{estimate.plvm}
\alias{estimate}
\alias{estimate.plvm}
\title{Penalized lvm model}
\usage{
\method{estimate}{plvm}(x, data, lambda1, lambda2, lambdaN, adaptive = FALSE,
  control = list(), estimator = "penalized", regularizationPath = FALSE,
  resolution_lambda1 = c(0.1, 0.001), increasing = TRUE,
  reversible = FALSE, stopLambda = NULL, stopParam = NULL,
  exportAllPath = FALSE, method.proxGrad = "ISTA", step = 1, BT.n = 100,
  BT.eta = 0.8, force.descent = FALSE, fit = "BIC", fixSigma = FALSE,
  ...)
}
\arguments{
\item{x}{a penalized lvm model}

\item{data}{a data.frame containing the data}

\item{lambda1}{lasso penalization parameter}

\item{lambda2}{ridge penalization parameter}

\item{lambdaN}{Nuclear norm penalization parameter}

\item{adaptive}{should the coefficient of the adaptive lasso be returned instead of the coefficient of the lasso}

\item{control}{control/optimization parameters}

\item{estimator}{the method used to compute the likelihood, gradient and hessian.}

\item{regularizationPath}{should the regularization path be computed. If so the argument lambda1 is ignored but not lambda2.}

\item{resolution_lambda1, increasing, stopLambda, stopParam}{arguments for the EPSODE function (see \code{EPSODE})}

\item{method.proxGrad, step, BT.n, BT.eta, force.descent}{arguments for the proximal gradient algorithm (see \code{proxGrad})}

\item{fit}{criterion to decide of the optimal model to retain among the penalized models.}

\item{fixSigma}{should the variance parameter be fixed at 1 ? Only works for regression models. [temporary]}

\item{...}{additional arguments to be passed to lava:::estimate.lvm}
}
\value{
a plvmfit object
}
\description{
Estimate a penalized lvm model
}
\details{
Available estimators are:
\itemize{
 \item{"penalized"}{ the hessian is computed as E[t(S) S]}
 \item{"numDeriveSimple"}{ the hessian is computed using numerical derivatives}
 \item{"numDeriveRichardson"}{ the hessian is computed using numerical derivatives (Richardson method)}
 \item{"explicit"}{ the hessian is computed using an explicit formula}
}
}
\examples{
# library(ggplot2)
# library(lava)

####> linear regression ####
set.seed(10)
n <- 300
formula.lvm <- as.formula(paste0("Y~",paste(paste0("X",1:12), collapse = "+")))
mSim <- lvm(formula.lvm)
categorical(mSim,labels=c("A","B","C")) <- "X1"
categorical(mSim,labels=c("A","B","C")) <- "X11"
df.data <- sim(mSim,n)

lvm.model <- lvm(formula.lvm)
plvm.model <- penalize(lvm.model)

## no penalty
fit <- estimate(lvm.model,  data = df.data)
fit

pfit <- estimate(plvm.model,  data = df.data, lambda1 = 0, control = list(constrain = TRUE))
pfit

#### lasso penalty
pfit <- estimate(plvm.model,  data = df.data, lambda1 = 116, control = list(constrain = TRUE))
pfit

## regularization path
path1F <- estimate(plvm.model,  data = df.data, regularizationPath = TRUE, fixSigma = TRUE)
getPath(path1F, order = "lambda1.abs")

path1B <- estimate(plvm.model,  data = df.data, regularizationPath = TRUE, fixSigma = TRUE, 
                   increasing = FALSE, resolution_lambda1 = c(1,1e-3))
path1B

getPath(path1B, order = "lambda1.abs")

#### ridge penalty


#### elastic net penalty

#### group lasso penalty

#### nuclear norm penalty


plot(path1B, type = "path", lambda = "lambda1.abs")
plot(path1B,  lambda = "lambda1.abs")
}
\references{
Zhou 2014 - A generic Path Algorithm for Regularized Statistical Estimation \cr
Park 2007 - L1-regularization path algorithm for GLM
}

